#!/usr/bin/perl

use strict; use warnings; use utf8;
use feature qw/say switch/;

use Encode;
use charnames ':full'; # "\N{WHITE SMILING FACE}";
use Data::Dumper;
use POSIX qw(floor);

use L2U::Constants;

# -- main()
# ----------------------------------------------------------------------

my $input = decode_utf8 join ' ', @ARGV;

pretty_print(expand(substitute_chars(normalize_input($input))));

# -- Subroutines
# ----------------------------------------------------------------------

sub pretty_print {
    my $box = shift; # reference

    say encode_utf8 $_ foreach @{$box->{content}};
}

sub expand {
    # TODO Allow for arrays to be passed
    my @str = split //, shift;
    my @stack;

    while (@str) {
        given (shift @str) {
            when (is_primitive($_)) {
                my $box = { # TODO Write a routine?  put_into_box()?
                    content => [ $_ ],
                    foot    => 0,
                    head    => 0,
                    width   => 1,
                    height  => 1,
                };
                push @stack, $box;
            }
            when (/\\/) { # Encountered macro sign, find handler.
                push @stack, process_macro(\@str);
            }
            # The power and subscript signs (exponents and indices) are
            # an inconvenient (as seen from here) inversion of the macro
            # concept: their handlers need to know what block went
            # *before*.  TODO Are there more of these?
            when (/\^/) {
                push @stack, handle('power', \@str, \@stack);
            }
            when (/_/)  { # The sub-index sign is, too.
                push @stack, handle('sub', \@str, \@stack);
            }
            default { die "New character class?!" }
        }
    }

    return boxify(@stack);
}

sub boxify {
    my @boxes = @_; # List of references.

    # Find the maximum box parameters for padding
    my ($height, $foot, $head) = (1, 0, 0);
    foreach my $box (@boxes) {
        $box->{height} > $height ? $height = $box->{height} : 1;
        $box->{foot} > $foot     ? $foot   = $box->{foot}   : 1;
        $box->{head} > $head     ? $head   = $box->{head}   : 1;
    }

    foreach my $box (@boxes) {
        vpad($foot, $head, $box);
    }

    # What I'm trying to express here is something like
    # '$content[0] = box1[0] . box2[0] . box3[0]'.
    my @content;
    for my $i (0 ..  $height-1) {
        my $line = '';
        $line .= $_->{content}->[$i] foreach (@boxes);
        push @content, $line;
    }

    my $box = {
        content => \@content,
        width   => length($content[0]),
        height  => $height,
        foot    => $foot,
        head    => $head,
    };

    return $box;
}

sub vpad {
    my $foot = shift;
    my $head = shift;
    my $box  = shift;  # Reference

    my $width   = $box->{width};  # TODO Calculate?
    my @content = @{$box->{content}};

    while ($box->{head}++ < $head) {
        unshift @content, " "x$width;
    }
    while ($box->{foot}++ < $foot) {
        push @content, " "x$width;
    }

    $box->{content} = \@content;
    $box->{height}  = $#content +1;
    $box->{foot}    = $foot;  # TODO Calculate!
    $box->{head}    = $head;

    return 1;  # TODO Error checking.
}

sub hpad {
    my @boxes = @_;  # References
    my $width = 1;   # Minimal box width.

    # Find maximum box width
    foreach my $box (@boxes) {
        $width < $box->{width} ? $width = $box->{width} : 0;
    }

    foreach my $box (@boxes) {
        my @content = @{$box->{content}};
        foreach my $line (@content) {
            my $pad = floor( ($width - length($line)) / 2);
            $line = " "x$pad . $line . " "x$pad;
            if ( $width - length($line) > 0 ) {
                # Pad one extra to the left for odd lengths
                $line = " $line";
            }
        }
        $box->{content} = \@content;
        $box->{width} = $width;
    }

    return 1;
}

# TODO Sorely lacking!  Primitive should be sth. like [:alnum:].
sub is_primitive { return (shift =~ /(\\|\^|_)/ ? '' : 1) }

sub is_unit_box {
    my $box = shift;
    return 1 if ($box->{width} * $box->{height} == 1);
    return 0;
}

sub is_superscriptable {
    my $box = shift;

    return 0 unless (is_unit_box($box));

    my $char = $box->{content}->[0];
    my $superscripts = get_superscripts;
    if (defined $superscripts->{$char}) {
        return $superscripts->{$char};
    } else {
        return 0;
    }
}

sub is_subscriptable {
    my $box = shift;
    my $char = $box->{content}->[0];
    my $subscripts = get_subscripts;
    if (defined $subscripts->{$char}) {
        return $subscripts->{$char};
    } else {
        return 0;
    }
}

sub process_macro {
    my $str = shift; # reference
    my $cmd;

    while ($str->[0] =~ /[a-zA-Z]/) {
        $cmd .= shift @$str;
    }

    return handle($cmd, $str);
}

sub handle {
    my $cmd = shift; # string
    my $str = shift; # reference
    my $stack = shift; # optional reference
    my $box;

    given($cmd) {
        when (/vec/)   { $box = handle_vec($str) }
        when (/frac/)  { $box = handle_frac($str) }
        when (/power/) { $box = handle_power($str, $stack) }
        when (/sub/) {  # TODO Duplicates a lot of code from 'power'.
            my $exp = find_blocks(1, $str);
            if ( my $sub = is_subscriptable($exp) ) {
                $box = {
                    content => [ $sub ],
                    width => 1,
                    height => 1,
                    foot => 0,
                    head => 0,
                };
            } else {
                unshift @{$exp->{content}}, " " x length($exp->{content}->[0]);
                $exp->{foot} = $exp->{height};
                $exp->{head} = 0;
                $exp->{height}++;
                $box = $exp;
            };
        }
        when (/int/) { $box = handle_int($str) }
        default      { die "Unknown command.  Can't handle." }
    }
    return $box;
}

sub handle_vec {
    D("> handle_vec");
    my $str = shift;

    # TODO Check for single character!
    my $char = find_blocks(1, $str);
    $char->{content}->[0] = $char->{content}->[0] . "\x{20d7}";
    return $char;
}

sub handle_frac {
    D("> handle_frac");
    my $str = shift; # Reference
    my $box;

    my ($num, $denom) = find_blocks(2, $str);
    hpad($num, $denom);
    my @frac = @{$num->{content}};
    push @frac, "\x{2015}"x($num->{width}+2);
    push @frac, @{$denom->{content}};

    $box = {
        content => \@frac,
        width   => length($frac[0])+2,
        height  => $#frac + 1,
        foot    => $denom->{height},
        head    => $num->{height},
    };
    hpad($box);

    return $box;
}

sub handle_power {
    D("> handle_power");
    my $str = shift; #reference
    my $stack = shift; #reference
    my ($min_head, $min_foot) = (0, 0);
    my $box;

    if (not defined $stack->[-1]) {
        say STDERR "No block before '^' sign?";
    } else {
        $min_head = $stack->[-1]->{head};
        $min_foot = $stack->[-1]->{foot};
    }

    my $exp = find_blocks(1, $str);
    if (my $super = is_superscriptable($exp) and $min_head == 0)
    {
        $box = {
            content => [ $super ],
            width   => 1,  height  => 1,
            foot    => 0,  head    => 0,
        };
    } else {
        foreach my $i (0 .. $min_head+$min_foot) {
            push @{$exp->{content}}, " " x length($exp->{content}->[0]);
        }
        $exp->{head} = $min_head + $exp->{height};
        $exp->{foot} = $min_foot;
        $exp->{height} = $exp->{head} + 1 + $min_foot;
        $box = $exp;
    };
    return $box;
}

sub find_limits {
    my $str = shift;
    my ($upper, $lower);

    foreach (0 .. 1) {
        given ($str->[0]) {
            when (/\^/) { # upper limit
                shift @$str;
                $upper = find_blocks(1, $str);
            }
            when (/_/)  { # lower limit
                shift @$str;
                $lower = find_blocks(1, $str);
            }
            default { return undef }
        }
    }

    return ($upper, $lower);
}

sub handle_int {
    D('> handle_int');
    my $str             = shift;
    my ($upper, $lower) = find_limits($str);
    my $arg             = find_blocks(1, $str);

    my @content;
    my $intbox = {
        width => 1,
        height => $arg->{height},
        head => $arg->{head},
        foot => $arg->{foot},
    };

    if ($arg->{height} == 1) {
        @content = ( "\x{222B}" );
    } else {
        push @content, "\x{256d}";
        push @content, "\x{2502}" foreach (1 .. ($arg->{height}-2));
        push @content, "\x{256f}";
    }
    $intbox->{content} = \@content;

    # TODO Make a vboxify function from these lines.
    if ($upper) {
        hpad($upper, $intbox);
        unshift @{$intbox->{content}}, @{$upper->{content}};
        $intbox->{height} += $upper->{height};
        $intbox->{head}   += $upper->{height};
    }
    if ($lower) {
        hpad($lower, $intbox);
        push @{$intbox->{content}}, @{$lower->{content}};
        $intbox->{height} += $lower->{height};
        $intbox->{foot}   += $lower->{height};
    }

    return boxify($intbox, $arg);
}

# TODO Reimplement as find_block, handle_frac could just call it twice.
sub find_blocks {
    my $count = shift;
    my $str   = shift;  # Reference.

    # Call find_blocks recursive if more than one block need to be
    # found.
    if ($count > 1) {
        my @boxes;
        while ($count > 0) {
            $boxes[--$count] = find_blocks(1, $str);
        }
        return reverse @boxes;
    } else {
        my $box;

        if ($str->[0] !~ /(\{|\})/) {
            $box = {
                content => [ shift @$str ],
                height  => 1,
                width   => 1,
                foot    => 0,
                head    => 0,
            };
        } else { # Real block begins
            my $block = '';
            my $depth = 0;

            while (scalar(@$str)) {
                my $char = shift @$str;
                given ($char) {
                    when (/\{/) {
                        $block .= $char if ($depth > 0);
                        $depth++;
                    }
                    when (/\}/) {
                        $depth--;
                        $block .= $char if ($depth > 0);
                        last if ($depth == 0);
                    }
                    #when (is_primitive($_)) { $block = $char }
                    default { $block .= $char }
                }
            }
            $box = expand($block);
        }

        return $box;
    }
}

sub normalize_input { # TODO _Very_ dangerous: '\times a' -> '\timesa'
    my $in = shift;

    $in =~ s/\s//g;

    return $in;
}

sub substitute_chars {
    my $in = shift;
    my $chars = get_primitive_chars;

    while (my ($tex, $code) = each %$chars) {
        $in =~ s/\\$tex/$code/g;
    }

    return $in;
}

