#!/usr/bin/perl

use strict; use warnings; use utf8;
use feature qw/say switch/;

use Encode;
use charnames ':full'; # "\N{WHITE SMILING FACE}";
use Data::Dumper;
use POSIX qw(floor);

use L2U::Constants;

# -- main()
# ----------------------------------------------------------------------

my $input = decode_utf8 join ' ', @ARGV;

pretty_print(expand(substitute_chars(normalize_input($input))));

# -- Subroutines
# ----------------------------------------------------------------------

sub pretty_print {
    my $box = shift; # reference

    say encode_utf8 $_ foreach @{$box->{content}};
}

sub expand {
    # TODO Allow for arrays to be passed
    my @str = split //, shift;
    my @stack;

    while (@str) {
        given (shift @str) {
            when (is_primitive($_)) {
                my $box = { # TODO Write a routine?  put_into_box()?
                    content => [ $_ ],
                    foot    => 0,
                    head    => 0,
                    width   => 1,
                    height  => 1,
                };
                push @stack, $box;
            }
            when (/\\/) { # Encountered macro sign, find handler.
                push @stack, process_macro(\@str);
            }
            when (/\^/) { # The power sign is just a shorthand.
                push @stack, handle('power', \@str);
            }
            when (/_/)  { # The sub-index sign is, too.
                push @stack, handle('sub', \@str);
            }
            default { die "New character class?!" }
        }
    }

    return boxify(@stack);
}

sub boxify {
    my @boxes = @_; # List of references.

    # Find the maximum box parameters for padding
    my ($height, $foot, $head) = (1, 0, 0);
    foreach my $box (@boxes) {
        $box->{height} > $height ? $height = $box->{height} : 1;
        $box->{foot} > $foot     ? $foot   = $box->{foot}   : 1;
        $box->{head} > $head     ? $head   = $box->{head}   : 1;
    }

    foreach my $box (@boxes) {
        vpad($foot, $head, $box);
    }

    # What I'm trying to express here is something like
    # '$content[0] = box1[0] . box2[0] . box3[0]'.
    my @content;
    for my $i (0 ..  $height-1) {
        my $line = '';
        $line .= $_->{content}->[$i] foreach (@boxes);
        push @content, $line;
    }

    my $box = {
        content => \@content,
        width   => length($content[0]),
        height  => $height,
        foot    => $foot,
        head    => $head,
    };

    return $box;
}

sub vpad {
    my $foot = shift;
    my $head = shift;
    my $box  = shift;  # Reference

    my $width   = $box->{width};  # TODO Calculate?
    my @content = @{$box->{content}};

    while ($box->{head}++ < $head) {
        unshift @content, " "x$width;
    }
    while ($box->{foot}++ < $foot) {
        push @content, " "x$width;
    }

    $box->{content} = \@content;
    $box->{height}  = $#content +1;
    $box->{foot}    = $foot;  # TODO Calculate!
    $box->{head}    = $head;

    return 1;  # TODO Error checking.
}

sub hpad {
    my @boxes = @_;  # References
    my $width = 1;   # Minimal box width.

    # Find maximum box width
    foreach my $box (@boxes) {
        $width < $box->{width} ? $width = $box->{width} : 0;
    }

    foreach my $box (@boxes) {
        my @content = @{$box->{content}};
        foreach my $line (@content) {
            my $pad = floor( ($width - length($line)) / 2);
            $line = " "x$pad . $line . " "x$pad;
            if ( $width - length($line) > 0 ) {
                # Pad one extra to the left for odd lengths
                $line = " $line";
            }
        }
        $box->{content} = \@content;
        $box->{width} = $width;
    }

    return 1;
}

# TODO Sorely lacking!  Primitive should be sth. like [:alnum:].
sub is_primitive { return (shift =~ /(\\|\^|_)/ ? '' : 1) }

sub is_unit_box {
    my $box = shift;
    return 1 if ($box->{width} * $box->{height} == 1);
    return 0;
}

sub is_superscriptable {
    my $box = shift;

    return 0 unless (is_unit_box($box));

    my $char = $box->{content}->[0];
    my $superscripts = get_superscripts;
    if (defined $superscripts->{$char}) {
        return $superscripts->{$char};
    } else {
        return 0;
    }
}

sub is_subscriptable {
    my $box = shift;
    my $char = $box->{content}->[0];
    my $subscripts = get_subscripts;
    if (defined $subscripts->{$char}) {
        return $subscripts->{$char};
    } else {
        return 0;
    }
}

sub process_macro {
    my $str = shift; # reference
    my $cmd;

    while ($str->[0] =~ /[a-zA-Z]/) {
        $cmd .= shift @$str;
    }

    return handle($cmd, $str);
}

sub handle {
    my $cmd = shift; # string
    my $str = shift; # reference
    my $box;

    given($cmd) {
        when (/frac/) {
            my ($num, $denom) = find_blocks(2, $str);
            hpad($num, $denom);
            my @frac = @{$num->{content}};
            push @frac, "\x{2015}"x$num->{width};
            push @frac, @{$denom->{content}};
            $box = {
                content => \@frac,
                width   => length($frac[0]),
                height  => $#frac + 1,
                foot    => $denom->{height},
                head    => $num->{height},
            };
        }
        when (/power/) {
            my $exp = find_blocks(1, $str);
            if ( my $super = is_superscriptable($exp) ) {
                $box = {
                    content => [ $super ],
                    width => 1,
                    height => 1,
                    foot => 0,
                    head => 0,
                };
            } else {
                push @{$exp->{content}}, " " x length($exp->{content}->[0]);
                $exp->{head} = $exp->{height};
                $exp->{foot} = 0;
                $exp->{height}++;
                $box = $exp;
            };
        }
        when (/sub/) {
        }
    }
    return $box;
}

sub find_blocks {
    my $count = shift;
    my $str   = shift;  # Reference.

    # Call find_blocks recursive if more than one block need to be
    # found.
    if ($count > 1) {
        my @boxes;
        while ($count > 0) {
            $boxes[--$count] = find_blocks(1, $str);
        }
        return reverse @boxes;
    } else {
        my $box;

        if ($str->[0] !~ /(\{|\})/) {
            $box = {
                content => [ shift @$str ],
                height  => 1,
                width   => 1,
                foot    => 0,
                head    => 0,
            };
        } else { # Real block begins
            my $block = '';
            my $depth = 0;

            while (my $char = shift @$str) {
                given ($char) {
                    when (/\{/) { $depth++ }
                    when (/\}/) {
                        $depth--;
                        if ($depth < 0) {
                            die "Weird block structure.";
                        } elsif ($depth == 0) {
                            last;
                        }
                    }
                    #when (is_primitive($_)) { $block = $char }
                    default { $block .= $char }
                }
            }
            $box = expand($block);
        }

        return $box;
    }
}

sub normalize_input { # TODO _Very_ dangerous: '\times a' -> '\timesa'
    my $in = shift;

    $in =~ s/\s//g;

    return $in;
}

sub substitute_chars {
    my $in = shift;
    my $chars = get_primitive_chars;

    while (my ($tex, $code) = each %$chars) {
        $in =~ s/\\$tex/$code/g;
    }

    return $in;
}

